---
title: Tutorial #2 - Chat Monitor
description: 
published: true
date: 2024-09-24T08:57:28.334Z
tags: 
editor: markdown
dateCreated: 2024-09-24T08:27:42.804Z
---

# Tutorial #2 - Chat Monitor

This tutorial explains how to build an application that listens for chat messages and parses them when they arrive. When it receives a chat message with a special message inside, it sends its own transaction out onto the network to celebrate. This covers sending and receiving transactions.

## Creating Module Directory

Navigate into your ```/mods``` directory and create a folder with the name ```tutorial02```. Within that directory create the file ```tutorial02.js```. Copy the text below into this this file.

```
var ModTemplate = require('../../lib/templates/modtemplate');

class Tutorial02 extends ModTemplate {

  constructor(app) {

    super(app);

    this.name            = "Tutorial01";
    this.slug            = "tutorial01";
    this.description     = "Listening for Chat Messages";

    return this;

  }

}

module.exports = Tutorial01;
```

## Listening for Inbound Transactions

We want our application to listen for messages that have been sent to the Chat module, so we add the following function which will ensure that whenever Saito receives a Chat message, our module is notified and has the option of processing it!

```
        shouldAffixCallbackToModule(modname) {
                if (modname == this.name) { return 1; }
                if (modname == 'Chat') { return 1; }
                return 0;
        }
```

There are two functions that we need to provide to get our module listening to inbound messages. The first function ```onConfirmation()``` runs whenever transactions are received on-chain, while the second function ```handlPeerTransaction()``` runs if a transaction arrives directly off-chain from one of our peers. In both cases, we are sent a transaction object to process, and forward it to a third function that will analyse the transaction.

```
        async onConfirmation(blk, tx, conf) {
  
                let txmsg = tx.returnMessage();
                        
                if (conf == 0) {
 								        if (txmsg.module == "Chat") {		
 																this.processChatTransaction(txmsg);
				  							}
  							}
         }
  

        async handlePeerTransaction(app, tx, peer, mycallback = null) {
        
                let txmsg = tx.returnMessage();
                        
       	        if (txmsg.module == "Chat") {		
 												this.processChatTransaction(txmsg);
								}
         }
 ```
 
When our module receives a transaction, it will extract the ```message``` field from the transaction. This is an associative array which is formatted. It checks to see if this transaction is intended for the Chat module and sends it to a new function inside its own module called ```processChatTrasaction(txmsg)```. Let's move on to code this function.

```
        async processChatTransaction(txmsg) {
                 if (txmsg.message) {
                        if (txmsg.message.indexOf("huzzah") > -1) {
												        if (this.app.BROWSER) {
																				alert("Huzzah!");                             
                                }
                        }
								}
         }
 ```

Compile this application and run it, and then load up RedSquare. If you type "huzzah" into the chat box, it will be sent out into the network . At that point, the message will bounce back and your browser will receive it. When it receives it, it will pass the Chat Transaction into your new module, which will pass it to ```processChatTransaction()``` and result in your alert.


## Sending a Transaction

Instead of just throwing up an alert, ket's have our module send a transaction itself to celebrate. In order to do this, let's modify the function processChatTransaction(txmsg) so that instead of just throwing up an alert, it creates a transaction and broadcasts it into the network.

```
        async processChatTransaction(txmsg) {
                 if (txmsg.message) {
                        if (txmsg.message.indexOf("huzzah") > -1) {
												        if (this.app.BROWSER) {
																				let newtx = this.app.wallet.createUnsignedTransaction();
                                        newtx.msg = {
                                        				module : "Tutorial02" ,
                               									huzzah : true
                                        }
                                        this.app.wallet.signTransaction(newtx);
                                        this.app.network.propagateTransaction(newtx);
																				alert("Huzzah Transaction Sent!");                             
                                }
                        }
								}
         }
 ```

Open the file ```/config/modules.config.js```. This file contains two lists of modules. The first list is in the ```core``` section -- it lists the modules that will run on your server. The second is in the ```lite``` section -- it lists the modules that your server will compile for any lite-clients that connect to it and ask for the default set of applications.

There is no reason to add this module to your server because it won't do anything, but you should add it to the list of modules in the ```lite``` section that will be compiled and provided to browsers. Then navigate to ```/saito-lite-rust``` and compile the javascript bundle:

```
> npm run nuke
```

If this is not your first time compiling the software you can run ```npm run compile``` instead. If you run into trouble we have more detailed instructions on how to compile applications right here. Once your application compiles, start Saito by running ```npm start```,


## Using Your Application

Start up your local node and navigate to any application. As your browser initializes you will see an alert() message popup regardless of which application you are viewing. This is because the code in ```initialize(app)``` runs each time you start running Saito. Here is what it looks like on the Arcade.

<br />
<img src="/tutorials/01/arcade.png" style="max-width:600px" />

To trigger our code in the ```render()``` function, we need to tell Saito to run the render function in our new module. We do this by pointing our browser to the ```/tutorial01``` application. You'll see that your module is grabbing the default HTML and replacing it with its own message as below:

<br />
<img src="/tutorials/01/render.png" style="max-width:600px" />



## Reference Materials

If you would like to test this application without compiling it yourself, you can find a pre-packaged version available for installation into your browser here. Download the file and drag-and-drop it into your browser. The See here for instructions on compiling your own application into this portable format.

You can find the complete source code associated with this tutorial in the default ```/mods``` directory.  Alternately, you can access all of the files in this tutorial by downloading this [ZIP file](/tutorial01_(2).zip). Or just download this application as a [precompiled Saito module](/) and install it into your wallet.



In our [next tutorial](/tech/tutorial-2-chat) we’ll create an application that can receive transactions in addition to sending them. Before we get to that, there’s something important you may have realized: the Saito AppStore is an application like any other application. Although our tutorial series starts with small applications, there’s no limit to the complexity of the applications that you want to build.

